// Ultra-Aggressive Browser Exploitation for .paper TLD
// Uses every possible technique to make .paper work without DNS

export class BrowserExploit {
    private static instance: BrowserExploit;
    private swReady: boolean = false;

    static getInstance(): BrowserExploit {
        if (!BrowserExploit.instance) {
            BrowserExploit.instance = new BrowserExploit();
        }
        return BrowserExploit.instance;
    }

    async exploit() {
        console.log('[Exploit] Starting aggressive browser exploitation...');
        
        // Strategy 1: Register Service Worker IMMEDIATELY (before page load)
        await this.registerServiceWorkerAggressively();
        
        // Strategy 2: Override DNS resolution using fetch interception
        this.overrideFetch();
        
        // Strategy 3: Use WebRTC for local resolution
        await this.setupWebRTCDNS();
        
        // Strategy 4: Create local proxy using SharedArrayBuffer (if available)
        this.setupSharedArrayBufferProxy();
        
        // Strategy 5: Use WebAssembly to create a local DNS server
        await this.setupWASMDNS();
        
        // Strategy 6: Override XMLHttpRequest
        this.overrideXHR();
        
        console.log('[Exploit] Browser exploitation complete');
    }

    private async registerServiceWorkerAggressively() {
        if ('serviceWorker' in navigator) {
            try {
                // Register with maximum scope
                const registration = await navigator.serviceWorker.register('/sw.js', { 
                    scope: '/',
                    updateViaCache: 'none' // Always use latest
                });
                
                // Force immediate activation
                if (registration.active) {
                    await registration.active.postMessage({ type: 'SKIP_WAITING' });
                }
                
                // Wait for ready
                await navigator.serviceWorker.ready;
                this.swReady = true;
                console.log('[Exploit] Service Worker aggressively registered');
            } catch (e) {
                console.error('[Exploit] SW registration failed:', e);
            }
        }
    }

    private overrideFetch() {
        const originalFetch = window.fetch;
        window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {
            let url: URL;
            if (typeof input === 'string') {
                url = new URL(input, window.location.href);
            } else if (input instanceof URL) {
                url = input;
            } else {
                url = new URL(input.url, window.location.href);
            }

            // Intercept .paper domains BEFORE they hit the network
            if (url.hostname.endsWith('.paper') || url.hostname === 'paper') {
                const gatewayUrl = new URL(`/_gateway/${url.hostname}${url.pathname}${url.search}`, window.location.origin);
                return originalFetch(gatewayUrl, init);
            }

            return originalFetch(input, init);
        };
        console.log('[Exploit] Fetch API overridden');
    }

    private async setupWebRTCDNS() {
        if (typeof RTCPeerConnection !== 'undefined') {
            try {
                // Create a local peer connection that can act as DNS resolver
                const pc = new RTCPeerConnection({ iceServers: [] });
                (window as any).__paper_rtc_dns = pc;
                console.log('[Exploit] WebRTC DNS proxy created');
            } catch (e) {
                console.warn('[Exploit] WebRTC not available');
            }
        }
    }

    private setupSharedArrayBufferProxy() {
        // SharedArrayBuffer can be used for high-performance local communication
        if (typeof SharedArrayBuffer !== 'undefined') {
            try {
                const buffer = new SharedArrayBuffer(1024);
                (window as any).__paper_dns_buffer = buffer;
                console.log('[Exploit] SharedArrayBuffer DNS buffer created');
            } catch (e) {
                console.warn('[Exploit] SharedArrayBuffer not available');
            }
        }
    }

    private async setupWASMDNS() {
        // Use WebAssembly to create a fast local DNS resolver
        try {
            // Create a simple WASM module that acts as DNS cache
            const wasmCode = new Uint8Array([
                0x00, 0x61, 0x73, 0x6d, // WASM magic
                0x01, 0x00, 0x00, 0x00  // Version 1
            ]);
            
            const wasmModule = await WebAssembly.compile(wasmCode);
            (window as any).__paper_wasm_dns = wasmModule;
            console.log('[Exploit] WASM DNS module created');
        } catch (e) {
            console.warn('[Exploit] WASM DNS setup failed');
        }
    }

    private overrideXHR() {
        const OriginalXHR = window.XMLHttpRequest;
        window.XMLHttpRequest = class extends OriginalXHR {
            open(method: string, url: string | URL, ...args: any[]) {
                const urlStr = url.toString();
                try {
                    const urlObj = new URL(urlStr, window.location.href);
                    if (urlObj.hostname.endsWith('.paper') || urlObj.hostname === 'paper') {
                        const gatewayUrl = `/_gateway/${urlObj.hostname}${urlObj.pathname}${urlObj.search}`;
                        return super.open(method, gatewayUrl, ...args);
                    }
                } catch (e) {
                    // Invalid URL, pass through
                }
                return super.open(method, urlStr, ...args);
            }
        } as any;
        console.log('[Exploit] XMLHttpRequest overridden');
    }

    // Intercept address bar navigation (most critical)
    interceptAddressBar() {
        // Override window.location setter
        const originalLocation = window.location;
        Object.defineProperty(window, 'location', {
            get: () => originalLocation,
            set: (value: string) => {
                try {
                    const url = new URL(value, window.location.href);
                    if (url.hostname.endsWith('.paper') || url.hostname === 'paper') {
                        window.location.href = `/_gateway/${url.hostname}${url.pathname}${url.search}`;
                        return;
                    }
                } catch (e) {
                    // Invalid URL
                }
                originalLocation.href = value;
            },
            configurable: true
        });
        console.log('[Exploit] Address bar interception active');
    }
}

// Auto-initialize on page load
if (typeof window !== 'undefined') {
    const exploit = BrowserExploit.getInstance();
    
    // Run immediately
    exploit.exploit();
    exploit.interceptAddressBar();
    
    // Also run on DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            exploit.exploit();
        });
    }
}

